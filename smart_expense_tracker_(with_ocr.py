# -*- coding: utf-8 -*-
"""Smart Expense Tracker (with OCR

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

"""
Smart Expense Tracker (with OCR)
--------------------------------
- Extracts text from receipt images via Tesseract OCR (optional; falls back to plain text files).
- Parses date, total amount, currency, and vendor heuristically.
- Predicts category (Food, Travel, Groceries, Shopping, Utilities, Other) using:
  1) A trained ML model (TF-IDF + MultinomialNB) if training data is available, else
  2) Keyword rules as a fallback.
- Persists expenses in a local SQLite database.
- Provides CLI commands to add receipts, list expenses, edit categories, run reports, and export CSV.

Dependencies:
    pip install pytesseract opencv-python pandas scikit-learn python-dateutil

OS package (needed for OCR):
    - Install Tesseract OCR engine:
      macOS: brew install tesseract
      Ubuntu/Debian: sudo apt-get install tesseract-ocr
      Windows: Download installer from tesseract-ocr.github.io

Example:
    python expense_tracker.py add --files ./receipts/*.jpg --db expenses.db
    python expense_tracker.py list --db expenses.db --limit 20
    python expense_tracker.py report --db expenses.db --period 2025-08
    python expense_tracker.py export --db expenses.db --out expenses.csv
"""

from __future__ import annotations

import argparse
import glob
import os
import re
import sqlite3
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterable, List, Optional, Tuple

import pandas as pd
from dateutil import parser as dateparser
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB

# OCR dependencies are optional at runtime (we handle ImportError gracefully)
try:
    import pytesseract
    import cv2
    OCR_AVAILABLE = True
except Exception:
    OCR_AVAILABLE = False


DB_SCHEMA = """
CREATE TABLE IF NOT EXISTS expenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT,             -- ISO date YYYY-MM-DD
    amount REAL,
    currency TEXT,
    vendor TEXT,
    category TEXT,         -- nullable if unknown
    source_file TEXT,
    raw_text TEXT,
    created_at TEXT DEFAULT (datetime('now'))
);
"""


DEFAULT_RULES = {
    "Food": [
        r"\brestaurant\b", r"\bcafe\b", r"\bbar\b", r"\bgrill\b",
        r"\bburger\b", r"\bpizza\b", r"\bsushi\b", r"\bcoffee\b", r"\bstarbucks\b", r"\bmc ?donald"
    ],
    "Groceries": [
        r"\bsupermarket\b", r"\bgrocery\b", r"\bwhole foods\b", r"\baldi\b", r"\blidl\b", r"\btesco\b", r"\bcarrefour\b"
    ],
    "Travel": [
        r"\buber\b", r"\blime\b", r"\btax[iy]\b", r"\btrain\b", r"\bflight\b", r"\bairlines?\b", r"\bbus\b", r"\bhotel\b", r"\bbooking\.com\b"
    ],
    "Shopping": [
        r"\bamazon\b", r"\btarget\b", r"\bwalmart\b", r"\bmedia ?markt\b", r"\bzara\b", r"\bh&m\b", r"\bikea\b", r"\bdecathlon\b"
    ],
    "Utilities": [
        r"\belectric\b", r"\bgas\b", r"\bwater\b", r"\binternet\b", r"\btelecom\b", r"\bvodafone\b", r"\bo2\b", r"\btelekom\b"
    ],
}


@dataclass
class ParsedReceipt:
    date: Optional[str]
    amount: Optional[float]
    currency: Optional[str]
    vendor: Optional[str]
    raw_text: str
    source_file: str


# ---------- Database helpers ----------

def get_conn(db_path: str) -> sqlite3.Connection:
    conn = sqlite3.connect(db_path)
    conn.execute("PRAGMA journal_mode=WAL;")
    conn.execute(DB_SCHEMA)
    return conn


def insert_expense(conn: sqlite3.Connection, p: ParsedReceipt, category: Optional[str]) -> int:
    cur = conn.cursor()
    cur.execute(
        """INSERT INTO expenses (date, amount, currency, vendor, category, source_file, raw_text)
           VALUES (?, ?, ?, ?, ?, ?, ?)""",
        (p.date, p.amount, p.currency, p.vendor, category, p.source_file, p.raw_text)
    )
    conn.commit()
    return cur.lastrowid


# ---------- OCR & parsing ----------

def ocr_image(path: str) -> str:
    if not OCR_AVAILABLE:
        raise RuntimeError("OCR not available. Install Tesseract and pip packages (pytesseract, opencv-python).")
    img = cv2.imread(path)
    if img is None:
        raise RuntimeError(f"Failed to load image: {path}")
    # Basic pre-processing: grayscale + threshold can help OCR
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Adaptive threshold
    thr = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                cv2.THRESH_BINARY, 31, 15)
    text = pytesseract.image_to_string(thr)
    return text


# We’ll try to parse: date, amount (+ currency), vendor name (first big line or merchant-like token)

CURRENCY_RE = re.compile(r"(€|\$|£|usd|eur|gbp)", re.I)
AMOUNT_RE = re.compile(r"(?<!\d)(\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{2})|\d+\.\d{2})(?!\d)")
DATE_CANDIDATE_RE = re.compile(
    r"(\b\d{4}[/-]\d{1,2}[/-]\d{1,2}\b|\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b|\b\d{1,2}\s+[A-Za-z]{3,9}\s+\d{2,4}\b)",
    re.I
)


def parse_date(text: str) -> Optional[str]:
    # pick the first plausible date
    m = DATE_CANDIDATE_RE.search(text)
    if not m:
        return None
    try:
        dt = dateparser.parse(m.group(0), dayfirst=False, fuzzy=True)
        return dt.date().isoformat()
    except Exception:
        return None


def parse_amount_currency(text: str) -> Tuple[Optional[float], Optional[str]]:
    # Heuristic: total is usually the largest amount
    amounts = [a.replace(",", "") for a in AMOUNT_RE.findall(text)]
    vals = []
    for a in amounts:
        try:
            vals.append(float(a))
        except Exception:
            pass
    if not vals:
        return None, None
    amount = max(vals)
    # Currency: look for explicit symbols
    m = CURRENCY_RE.search(text)
    currency = None
    if m:
        sym = m.group(1).upper()
        if sym in ("€", "EUR"):
            currency = "EUR"
        elif sym in ("$", "USD"):
            currency = "USD"
        elif sym in ("£", "GBP"):
            currency = "GBP"
        else:
            currency = sym
    return amount, currency


def parse_vendor(text: str) -> Optional[str]:
    # Take the first non-trivial line (often merchant header)
    lines = [l.strip() for l in text.splitlines() if l.strip()]
    if not lines:
        return None
    # Ignore very short or purely numeric lines
    for line in lines[:10]:
        if len(line) >= 3 and not line.isdigit():
            # strip order/receipt words
            cleaned = re.sub(r"\b(receipt|invoice|order|ticket|voucher)\b", "", line, flags=re.I).strip(" -–|•:")
            if cleaned:
                return cleaned[:80]
    return lines[0][:80]


def parse_receipt_text(raw_text: str, source_file: str) -> ParsedReceipt:
    text_norm = raw_text
    date = parse_date(text_norm)
    amt, cur = parse_amount_currency(text_norm)
    vendor = parse_vendor(text_norm)
    return ParsedReceipt(date=date, amount=amt, currency=cur, vendor=vendor, raw_text=raw_text, source_file=source_file)


# ---------- Categorization ----------

CATEGORIES = ["Food", "Groceries", "Travel", "Shopping", "Utilities", "Other"]

RULESETS = {k: [re.compile(p, re.I) for p in v] for k, v in DEFAULT_RULES.items()}

def rules_predict(text: str) -> str:
    for cat, patterns in RULESETS.items():
        if any(p.search(text) for p in patterns):
            return cat
    # Additional keyword nudges
    if re.search(r"\b(supermarket|grocery|market)\b", text, re.I):
        return "Groceries"
    if re.search(r"\b(restaurant|food|meal)\b", text, re.I):
        return "Food"
    if re.search(r"\b(train|flight|uber|hotel|bus|taxi)\b", text, re.I):
        return "Travel"
    return "Other"


def fit_model(df_train: pd.DataFrame):
    """Train TF-IDF + MultinomialNB on labeled rows (category not null)."""
    df_labeled = df_train.dropna(subset=["category"])
    if df_labeled.empty:
        return None, None
    X_text = df_labeled["raw_text"].astype(str).tolist()
    y = df_labeled["category"].astype(str).tolist()
    vectorizer = TfidfVectorizer(stop_words="english", max_features=20000, ngram_range=(1, 2))
    X = vectorizer.fit_transform(X_text)
    clf = MultinomialNB()
    clf.fit(X, y)
    return vectorizer, clf


def ml_predict(vectorizer, clf, text: str) -> Optional[str]:
    if vectorizer is None or clf is None:
        return None
    X = vectorizer.transform([text])
    return str(clf.predict(X)[0])


# ---------- CLI commands ----------

def cmd_add(args):
    conn = get_conn(args.db)
    paths: List[str] = []
    for pattern in args.files:
        paths.extend(glob.glob(pattern))
    if not paths:
        print("No files matched.", file=sys.stderr)
        return

    # Prepare ML model if available (learn from existing labeled rows)
    df_all = pd.read_sql_query("SELECT * FROM expenses", conn)
    vec, clf = fit_model(df_all)

    added = 0
    for path in paths:
        ext = Path(path).suffix.lower()
        try:
            if ext in {".png", ".jpg", ".jpeg", ".webp", ".tif", ".tiff", ".bmp"}:
                raw = ocr_image(path) if args.ocr else ""
                if not raw and OCR_AVAILABLE:
                    raw = ocr_image(path)
                elif not raw:
                    print(f"[WARN] OCR disabled/unavailable for image: {path}")
            elif ext in {".txt"}:
                raw = Path(path).read_text(encoding="utf-8", errors="ignore")
            else:
                print(f"[SKIP] Unsupported file type: {path}")
                continue

            parsed = parse_receipt_text(raw, source_file=os.path.abspath(path))
            category = None
            if args.no_ml:
                category = rules_predict(parsed.raw_text)
            else:
                category = ml_predict(vec, clf, parsed.raw_text) or rules_predict(parsed.raw_text)

            row_id = insert_expense(conn, parsed, category)
            added += 1
            print(f"✅ Added #{row_id}: {parsed.date or '—'} | {parsed.amount or '—'} {parsed.currency or ''} | {parsed.vendor or 'Unknown'} | {category}")
        except Exception as e:
            print(f"[ERROR] {path}: {e}", file=sys.stderr)

    print(f"\nDone. Added {added} item(s).")


def cmd_list(args):
    conn = get_conn(args.db)
    q = "SELECT id, date, amount, currency, vendor, category, source_file FROM expenses ORDER BY date DESC, id DESC"
    if args.limit:
        q += f" LIMIT {int(args.limit)}"
    df = pd.read_sql_query(q, conn)
    if df.empty:
        print("No expenses yet.")
        return
    print(df.to_string(index=False))


def cmd_set_category(args):
    conn = get_conn(args.db)
    cur = conn.cursor()
    cur.execute("UPDATE expenses SET category=? WHERE id=?", (args.category, args.id))
    conn.commit()
    print(f"Updated #{args.id} -> category={args.category}")


def cmd_report(args):
    conn = get_conn(args.db)
    df = pd.read_sql_query("SELECT date, amount, currency, vendor, category FROM expenses", conn)
    if df.empty:
        print("No data.")
        return
    # Filter by period (YYYY or YYYY-MM)
    if args.period:
        p = args.period
        if re.fullmatch(r"\d{4}-\d{2}", p):
            df = df[df["date"].str.startswith(p, na=False)]
            period_label = p
        elif re.fullmatch(r"\d{4}", p):
            df = df[df["date"].str.startswith(p, na=False)]
            period_label = p
        else:
            print("Invalid --period. Use YYYY or YYYY-MM.", file=sys.stderr)
            return
    else:
        period_label = "ALL"

    # Group by category and sum
    df["amount"] = pd.to_numeric(df["amount"], errors="coerce")
    g = df.groupby("category", dropna=False)["amount"].sum().sort_values(ascending=False).fillna(0.0)

    print(f"=== Expense Report ({period_label}) ===")
    if "currency" in df and df["currency"].nunique() == 1:
        cur = df["currency"].dropna().unique()[0] if not df["currency"].dropna().empty else ""
    else:
        cur = ""  # mixed currencies
    total = df["amount"].sum(skipna=True)
    print(g.to_string())
    print("------------------------")
    print(f"TOTAL: {total:.2f} {cur}")


def cmd_export(args):
    conn = get_conn(args.db)
    df = pd.read_sql_query("SELECT * FROM expenses ORDER BY date, id", conn)
    if df.empty:
        print("No data.")
        return
    Path(args.out).parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(args.out, index=False)
    print(f"Exported {len(df)} rows -> {args.out}")


def cmd_recategorize(args):
    conn = get_conn(args.db)
    df = pd.read_sql_query("SELECT * FROM expenses", conn)
    if df.empty:
        print("No data.")
        return
    vec, clf = fit_model(df)
    updated = 0
    for idx, row in df.iterrows():
        if pd.isna(row["raw_text"]):
            continue
        new_cat = ml_predict(vec, clf, row["raw_text"]) or rules_predict(row["raw_text"])
        if row["category"] != new_cat:
            conn.execute("UPDATE expenses SET category=? WHERE id=?", (new_cat, int(row["id"])))
            updated += 1
    conn.commit()
    print(f"Re-categorized {updated} row(s).")


def build_parser():
    p = argparse.ArgumentParser(description="Smart Expense Tracker (with OCR)")
    p.add_argument("--db", default="expenses.db", help="SQLite DB path (default: expenses.db)")
    sub = p.add_subparsers(dest="cmd", required=True)

    # add
    a = sub.add_parser("add", help="Add receipts by OCR/text")
    a.add_argument("--files", nargs="+", required=True, help="File globs (e.g., ./receipts/*.jpg ./more/*.txt)")
    a.add_argument("--ocr", action="store_true", help="Force OCR processing for image files")
    a.add_argument("--no-ml", action="store_true", help="Disable ML; use rule-based categories only")
    a.set_defaults(func=cmd_add)

    # list
    l = sub.add_parser("list", help="List recent expenses")
    l.add_argument("--limit", type=int, default=25)
    l.set_defaults(func=cmd_list)

    # set-category
    e = sub.add_parser("set-category", help="Manually set a category")
    e.add_argument("--id", type=int, required=True)
    e.add_argument("--category", choices=CATEGORIES, required=True)
    e.set_defaults(func=cmd_set_category)

    # report
    r = sub.add_parser("report", help="Show totals by category")
    r.add_argument("--period", help="YYYY or YYYY-MM (e.g., 2025-08)")
    r.set_defaults(func=cmd_report)

    # export
    x = sub.add_parser("export", help="Export all data to CSV")
    x.add_argument("--out", default="expenses_export.csv")
    x.set_defaults(func=cmd_export)

    # recategorize
    rc = sub.add_parser("recategorize", help="Re-run categorization over all rows")
    rc.set_defaults(func=cmd_recategorize)

    return p


def main():
    parser = build_parser()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()